B  
 �B_��G@s�dZddlmZddlZddlZddlZddlZddlZddlZddl	Z	ddl 
 Z 
 ddlZddlZddl Z ddlZddlZddlZddlZddlZddlZddlZddlZddlZddlZddlZddlZddlZddlmZyddlZWnek 
 �rddlZYnXye Wne!k 
 �r*e"Z YnXddl#m$Z$ddl%m&Z&m'Z'm(Z(ddlm)Z)yddlm*Z*m+Z+m,Z,d	Z-Wnek 
 �r�d 
 Z-YnXddlm.Z/ddl0m1Z1m2Z2yddl3m4Z5e5j6Wnek 
 �r�dZ5YnXd dl7m8Z8ddl#m9Z9ddl#m:Z:e;d�e;d�e;d�e;d�e<Z=dej>k�r@dk�rLnne?d��e$j@�r\dZAdZBdZCdZDdZEdZFdZGdZHdZIdZJdZKdZLdZMdZNdZOdZPdZQdZRdZSGdd�deT�ZUdd�ZViZWdd�ZXdd�ZYd d!�ZZd"d#�Z[d$d%�Z\d&d'�Z]d(d)�Z^d*d+�Z_Z`d,d-�Zad.d/d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMddNddOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqdrgGZbGdsdI�dIec�ZdGdtdJ�dJed�ZeGdudv�dvee�ZfGdwdK�dKed�ZgGdxdL�dLed�ZhiZiejjddy�ZkdyZldzZmd ZndZod{Zpd|dm�Zqd}d0�Zrgfd~d�Zsd�d��Ztd�d��Zue�vd��Zwe�vd��ZxeuZyd�dR�Zzd�d/�Z{e{Z|d�d1�Z}d�d2�Z~d�d�d3�Zd�d4�Z�Gd�d`�d`�Z�Gd�da�dae��Z�Gd�dD�dD�Z�Gd�d��d�e��Z�Gd�dC�dC�Z�e�Z�Gd�dM�dMe?�Z�Gd�dE�dE�Z�d�dB�Z�d�dO�Z�d�dP�Z�d�dU�Z�d�dV�Z�d�dW�Z��dd�dX�Z�Gd�dg�dg�Z�eqe�e��Gd�dh�dhe��Z�Gd�di�die��Z�e����Gd�de�dee��Z�e��Z�Gd�d��d�e��Z�Gd�d��d�e��Z�Gd�dj�dje��Z�eqe 
 j�e��Gd�db�dbe��Z�Gd�dc�dce��Z�Gd�dd�dde��Z�eXd�id��d�dk�Z��dd�d?�Z��dd�d��Z�e�e 
 j�e���dd�d��Z�e�e�e��d�d��Z��dd�d��Z�d�d��Z�Gd�d��d��Z�d�d��Z�d�d��Z�d�d��Z�d�d��Z�e�ej�e��e�e5d���r�e�e5j�e��eXd�id��eXd�id��d�dl�Z�d�dĄZ�d�dƄZ�d�d<�Z��dd�dn�Z�d�dʄZ�e�ej�e��e�e 
 j�e��e�e5d���r,e�e5j�e��d�d̄Z�e�e�e��d�dZ�Z�d�dτZ�ifd�dфZ�d�dӄZ�d�dՄZ�d�dׄZ�d�dS�Z�e�vd١j�Z�e�vd�ej�ej�B�j�Z�Gd�dH�dH�Z�d�d݄Z�d�d߄Z�Gd�dF�dF�Z�Gd�d�d�eăZ�Gd�d�d�eăZ�e�e�e�d�Z�d�d�Z�Gd�d�d�eɃZ�d�dN�Z�Gd�dG�dGe:j�j̓Z�d�d�Z�d�d�Z�d�dY�Z�d�d�Z�d�dT�Z�d�d��Z�ej�d�eUd	d��d�d��Z�e�eփfd�d���Z�e�d�d���Z�Gd�dp�dpeكZ�dS(aZ 
 Package resource API 
 -------------------- 
  
 A resource is a logical file contained within a package, or a logical 
 subdirectory thereof.  The package resource API expects resource names 
 to have their path parts separated with ``/``, not whatever the local 
 path separator is.  Do not use os.path operations to manipulate resource 
 names being passed into the API. 
  
 The package resource API is designed to work with normal filesystem packages, 
 .egg files, and unpacked .egg files.  It can also work in a limited way with 
 .zip files and with custom PEP 302 loaders that support the ``get_data()`` 
 method. 
 �)�absolute_importN)�get_importer)�six)�urllib�map�filter)�utime)�mkdir�rename�unlinkTF)�open)�isdir�split�)� 
 py31compat)�appdirs)�	packagingz&pkg_resources.extern.packaging.versionz)pkg_resources.extern.packaging.specifiersz+pkg_resources.extern.packaging.requirementsz&pkg_resources.extern.packaging.markers)�r)r�zPython 3.4 or later is requiredc@seZdZdZdS)� PEP440Warningza 
     Used when there is an issue with a version or specifier not complying with 
     PEP 440. 
     N)�_name_� 
 _module�qualname�doc�rr�[C:\Users\cyber\AppData\Local\Temp\pip-install-benmykki\setuptools\pkg_resources\init_.pyrxsrcCs2ytj�|�Stjjk 
 r,tj�|�SXdS)N)r�version�Version�InvalidVersion� LegacyVersion)�vrrr� parse_versionsr!cKs"t��|�t�t�||��dS)N)�globals�update�state_vars�dict�fromkeys)�vartype�kwrrr�_declare_state�sr)cCs<i}t�}x,t��D] \}}|d|||�||<qW|S)N�_sget)r"r$�items)�state�g�kr rrr�_getstate_�s 
 r/cCs<t�}x0|��D]$\}}|dt|||||�qW|S)N�sset)r"r+r$)r,r-r.r rrr�_setstate_�s r1cCs|��S)N)�copy)�valrrr� 
 _sget_dict�sr4cCs|��|�|�dS)N)�clearr#)�key�obr,rrr� 
 _sset_dict�sr8cCs|��S)N)r/)r3rrr�_sget_object�sr9cCs|�|�dS)N)r1)r6r7r,rrr�_sset_object�sr:cGsdS)Nr)�argsrrr�<lambda>��r<cCsbt�}t�|�}|dk	r^tjdkr^y&dd�t�dd��|�d�f}Wntk 
 r\YnX|S)aZReturn this platform's maximum compatible version. 
  
     distutils.util.get_platform() normally reports the minimum version 
     of Mac OS X that would be required to use extensions produced by 
     distutils.  But what we want when checking compatibility is to know the 
     version of Mac OS X that we are running.  To allow usage of packages that 
     explicitly require a newer version of Mac OS X, we must also know the 
     current version of the OS. 
  
     If this condition occurs for any other platform with a version in its 
     platform strings, this function should be extended accordingly. 
     N�darwinzmacosx-%s-%s�.�r)        �get_build_platform�macosVersionString�match�sys�platform�join�_macosx_vers�group� 
 ValueError)�plat�mrrr�get_supported_platform�s  
 &rL�require� 
 run_script�get_provider�get_distribution�load_entry_point� get_entry_map�get_entry_info�iter_entry_points�resource_string�resource_stream�resource_filename�resource_listdir�resource_exists�resource_isdir�declare_namespace�working_set�add_activation_listener�find_distributions�set_extraction_path�cleanup_resources�get_default_cache�Environment� 
 WorkingSet�ResourceManager�Distribution�Requirement� 
 EntryPoint�ResolutionError�VersionConflict�DistributionNotFound�UnknownExtra�ExtractionError�parse_requirements�        safe_name�safe_version�get_platform�compatible_platforms�yield_lines�split_sections� 
 safe_extra�to_filename�invalid_marker�evaluate_marker�ensure_directory�normalize_path�EGG_DIST�BINARY_DIST�SOURCE_DIST� CHECKOUT_DIST�DEVELOP_DIST�IMetadataProvider�IResourceProvider�FileMetadata�PathMetadata�EggMetadata� EmptyProvider�empty_provider�NullProvider�EggProvider�DefaultProvider�ZipProvider�register_finder�register_namespace_handler�register_loader_type�fixup_namespace_packagesr�PkgResourcesDeprecationWarning�run_main�AvailableDistributionsc@seZdZdZdd�ZdS)rhz.Abstract base for dependency resolution errorscCs|jjt|j�S)N)�	_classr�reprr;)�selfrrr�repr�szResolutionError.repr_N)rrrrr�rrrrrh�sc@s<eZdZdZdZedd��Zedd��Zdd�Zd	d 
 �Z        dS)riz� 
     An already-installed version conflicts with the requested version. 
  
     Should be initialized with the installed Distribution and the requested 
     Requirement. 
 z3{self.dist} is installed but {self.req} is requiredcCs 
 |jdS)Nr)r;)r�rrr�distszVersionConflict.distcCs 
 |jdS)Nr)r;)r�rrr�reqszVersionConflict.reqcCs|jjft��S)N)�	_template�format�locals)r�rrr�reportszVersionConflict.reportcCs|s|S|j|f}t|�S)zt 
         If required_by is non-empty, return a version of self that is a 
         ContextualVersionConflict. 
 )r;�ContextualVersionConflict)r��required_byr;rrr�with_contextszVersionConflict.with_contextN) 
 rrrrr��propertyr�r�r�r�rrrrrisc@s&eZdZdZejdZedd��ZdS)r�z� 
     A VersionConflict that accepts a third parameter, the set of the 
     requirements that required the installed Distribution. 
 z by {self.required_by}cCs 
 |jdS)Nr@)r;)r�rrrr�*sz%ContextualVersionConflict.required_byN)rrrrrir�r�r�rrrrr�"s 
 r�c@sHeZdZdZdZedd��Zedd��Zedd��Zd	d 
 �Z        dd�Z 
 d S)rjz&A requested distribution was not foundzSThe '{self.req}' distribution was not found and is required by {self.requirers_str}cCs 
 |jdS)Nr)r;)r�rrrr�5szDistributionNotFound.reqcCs 
 |jdS)Nr)r;)r�rrr�	requirers9szDistributionNotFound.requirerscCs|js 
 dSd�|j�S)Nzthe applicationz, )r�rF)r�rrr� requirers_str=sz"DistributionNotFound.requirers_strcCs|jjft��S)N)r�r�r�)r�rrrr�CszDistributionNotFound.reportcCs|��S)N)r�)r�rrr�_strFszDistributionNotFound.str_N)rrrrr�r�r�r�r�r�r�rrrrrj/sc@seZdZdZdS)rkz>Distribution doesn't have an "extra feature" of the given nameN)rrrrrrrrrkJsrr@�����cCs|t|<dS)aRegister `provider_factory` to make providers for `loader_type` 
  
     `loader_type` is the type or class of a PEP 302 ``module._loader_``, 
     and `provider_factory` is a function that, passed a module object, 
     returns an ``IResourceProvider`` for that module. 
 N)�_provider_factories)�loader_type�provider_factoryrrrr�XscCstt|t�r$t�|�p"tt|��dSytj|}Wn&tk 
 rXt        |�tj|}YnXt 
 |dd�}tt|�|�S)z?Return an IResourceProvider for the named module or requirementr� 
 _loader_N) � 
 isinstancerfr\�findrM�strrD�modules�KeyError� 
 _import_�getattr� _find_adapterr�)�moduleOrReq�module�loaderrrrrObs 
 cCsd|s\t��d}|dkrLd}tj�|�rLttd�rLt�|�}d|krL|d}|�|�	d��|dS)Nr�z0/System/Library/CoreServices/SystemVersion.plist�	readPlist�ProductVersionr?) 
 rE�mac_ver�os�path�exists�hasattr�plistlibr��appendr)�_cacher�plist� plist_contentrrrrGos 
  
 rGcCsddd��||�S)N�ppc)�PowerPC�Power_Macintosh)�get)�machinerrr�_macosx_archsr�cCs|ddlm}|�}tjdkrx|�d�sxy<t�}t��d�dd�}dt	|d�t	|d	�t 
 |�fStk 
 rvYnX|S) 
 z�Return this platform's string for platform-specific distributions 
  
     XXX Currently this is the same as ``distutils.util.get_platform()``, but it 
     needs some hacks for Linux and Mac OS X. 
 r)rpr>zmacosx-r� �_zmacosx-%d.%d-%sr)�	sysconfigrprDrE� 
 startswithrGr��uname�replace�intr�rI)rprJrr�rrrrA�srAzmacosx-(\d+)\.(\d+)-(.)zdarwin-(\d+)\.(\d+)\.(\d+)-(.)cCs�|dks|dks||krdSt�|�}|r�t�|�}|s�t�|�}|r�t|�d��}d|�d�|�d�f}|dkr||dks�|dkr�|d	kr�dSd 
 S|�d�|�d�ks�|�d�|�d�kr�d 
 St|�d��t|�d��kr�d 
 SdSd 
 S)z�Can code for the `provided` platform run on the `required` platform? 
  
     Returns true if either platform is ``None``, or the platforms are equal. 
  
     XXX Needs compatibility checks for Linux and other unixy OSes. 
 NTrz%s.%sr@�z10.3�z10.4Fr)rBrC�darwinVersionStringr�rH)�provided�required�reqMac�provMac� 
 provDarwin�dversion�macosversionrrrrq�s* 
  
  
 cCs<t�d�j}|d}|��||d<t|�d�||�dS)z@Locate distribution `dist_spec` and run its `script_name` scriptrrrN)rD�	_getframe�	f_globalsr5rMrN)Z	dist_spec�script_name�ns�namerrrrN�s 
 cCs@t|tj�rt�|�}t|t�r(t|�}t|t�s<td|��|S)z@Return a current distribution object for a Requirement or stringz-Expected string, Requirement, or Distribution)r�r�string_typesrf�parserOre�	TypeError)r�rrrrP�s 
  
  
  
 cCst|��||�S)zDReturn `name` entry point of `group` for `dist` or raise ImportError)rPrQ)r�rHr�rrrrQ�scCst|��|�S)z=Return the entry point map for `group`, or the full entry map)rPrR)r�rHrrrrR�scCst|��||�S)z<Return the EntryPoint object for `group`+`name`, or ``None``)rPrS)r�rHr�rrrrS�sc@s<eZdZdd�Zdd�Zdd�Zdd�Zd	d 
 �Zdd�Zd S)rcCsdS)z;Does the package's distribution contain the named metadata?Nr)r�rrr�has_metadata�szIMetadataProvider.has_metadatacCsdS)z'The named metadata resource as a stringNr)r�rrr�get_metadata�szIMetadataProvider.get_metadatacCsdS)z�Yield named metadata resource as list of non-blank non-comment lines 
  
        Leading and trailing whitespace is stripped from each line, and lines 
 with ``#`` as the first non-blank character are omitted.Nr)r�rrr�get_metadata_lines�sz$IMetadataProvider.get_metadata_linescCsdS)z>Is the named metadata a directory? (like ``os.path.isdir()``)Nr)r�rrr�metadata_isdirsz IMetadataProvider.metadata_isdircCsdS)z?List of metadata names in the directory (like ``os.listdir()``)Nr)r�rrr�metadata_listdirsz"IMetadataProvider.metadata_listdircCsdS)z=Execute the named script in the supplied namespace dictionaryNr)r��	namespacerrrrN	szIMetadataProvider.run_scriptN)	rrrr�r�r�r�r�rNrrrrr�sc@s@eZdZdZdd�Zdd�Zdd�Zdd	�Zd 
 d�Zdd �Z	dS)r�z3An object that provides access to package resourcescCsdS)zdReturn a true filesystem path for `resource_name` 
  
 `manager` must be an ``IResourceManager``Nr)�manager� resource_namerrr�get_resource_filenamesz'IResourceProvider.get_resource_filenamecCsdS)ziReturn a readable file-like object for `resource_name` 
  
 `manager` must be an ``IResourceManager``Nr)r�r�rrr�get_resource_streamsz%IResourceProvider.get_resource_streamcCsdS)zmReturn a string containing the contents of `resource_name` 
  
 `manager` must be an ``IResourceManager``Nr)r�r�rrr�get_resource_stringsz%IResourceProvider.get_resource_stringcCsdS)z,Does the package contain the named resource?Nr)r�rrr�has_resourceszIResourceProvider.has_resourcecCsdS)z>Is the named resource a directory? (like ``os.path.isdir()``)Nr)r�rrrrZ"sz IResourceProvider.resource_isdircCsdS)z?List of resource names in the directory (like ``os.listdir()``)Nr)r�rrrrX%sz"IResourceProvider.resource_listdirN) 
 rrrrr�r�r�r�rZrXrrrrr� sc@s�eZdZdZd'dd�Zedd��Zedd��Zd	d 
 �Zdd�Z        d d�Z 
 d(dd�Zdd�Zdd�Z d)dd�Zd*dd�Zd+dd�Zdd�Zd,dd �Zd!d"�Zd#d$�Zd%d&�ZdS)-rczDA collection of active distributions on sys.path (or a similar list)NcCsBg|i|_i|_g||dkr&tj}x|D]}|�|�q,WdS)z?Create working set from list of path entries (default=sys.path)N)�entries� 
 entry_keys�by_key�	callbacksrDr��	add_entry)r�r��entryrrr�_init_,s 
 zWorkingSet._init_cCsZ|�}yddlm}Wntk 
 r*|SXy|�|�Wntk 
 rT|�|�SX|S)z1 
         Prepare the master working set. 
 r)�_requires)�main_r��ImportErrorrMri�_build_from_requirements)�cls�wsr�rrr� _build_master9szWorkingSet._build_mastercCsn|g�}t|�}|�|t��}x|D]}|�|�q$Wx"tjD]}||jkr>|�|�q>W|jtjdd�<|S)zQ 
         Build a working set from a requirement spec. Rewrites sys.path. 
 N)rm�resolverb�addrDr�r�r�)r��req_specr��reqs�distsr�r�rrrr�Ms 
  
 z#WorkingSet._build_from_requirementscCs@|j�|g�|j�|�x t|d�D]}|�||d�q&WdS)a�Add a path item to ``.entries``, finding any distributions on it 
  
         ``find_distributions(entry, True)`` is used to find distributions 
         corresponding to the path entry, and they are added.  `entry` is 
         always appended to ``.entries``, even if it is already present. 
         (This is because ``sys.path`` can contain the same value more than 
         once, and the ``.entries`` of the ``sys.path`` WorkingSet should always 
         equal ``sys.path``.) 
         TFN)r�� 
 setdefaultr�r�r^r�)r�r�r�rrrr�cs 
 zWorkingSet.add_entrycCs|j�|j�|kS)z9True if `dist` is the active distribution for its project)r�r�r6)r�r�rrr�_containsrszWorkingSet.contains_cCs,|j�|j�}|dk	r(||kr(t||��|S)a�Find a distribution matching requirement `req` 
  
         If there is an active distribution for the requested project, this 
         returns it as long as it meets the version requirement specified by 
         `req`.  But, if there is an active distribution for the project and it 
         does not meet the `req` requirement, ``VersionConflict`` is raised. 
         If there is no active distribution for the requested project, ``None`` 
         is returned. 
 N)r�r�r6ri)r�r�r�rrrr�vs 
  
 zWorkingSet.findcs��fdd�|D�S)aYield entry point objects from `group` matching `name` 
  
         If `name` is None, yields all entry points in `group` from all 
         distributions in the working set, otherwise only ones matching 
         both `group` and `name` are yielded (in distribution order). 
 c3s8|]0}|�����D]}�dks*�|jkr|VqqdS)N)rR�valuesr�)�.0r�r�)rHr�rr�	<genexpr>�sz/WorkingSet.iter_entry_points.<locals>.<genexpr>r)r�rHr�r)rHr�rrT�szWorkingSet.iter_entry_pointscCs>t�d�j}|d}|��||d<|�|�d�||�dS)z?Locate distribution for `requires` and run `script_name` scriptrrrN)rDr�r�r5rMrN)r��requiresr�r�r�rrrrN�s 
 zWorkingSet.run_scriptccsTi}xJ|jD]@}||jkrqx.|j|D] }||kr(d||<|j|Vq(WqWdS)z�Yield distributions for non-duplicate projects in the working set 
  
         The yield order is the order in which the items' path entries were 
         added to the working set. 
 rN)r�r�r�)r��seen�itemr6rrr�_iter_�s 
 zWorkingSet._iter_TFcCs�|r|j|j||d�|dkr$|j}|j�|g�}|j�|jg�}|sV|j|jkrVdS||j|j<|j|krx|�|j�|j|kr�|�|j�|�|�dS)aAdd `dist` to working set, associated with `entry` 
  
         If `entry` is unspecified, it defaults to the ``.location`` of `dist`. 
         On exit from this routine, `entry` is added to the end of the working 
         set's ``.entries`` (if it wasn't already present). 
  
         `dist` is only added to the working set if it's for a project that 
         doesn't already have a distribution in the set, unless `replace=True`. 
         If it's added, any callbacks registered with the ``subscribe()`` method 
         will be called. 
 )r�N)	�	insert_onr��locationr�r�r6r�r�� 
 _added_new)r�r�r��insertr��keys�keys2rrrr��s 
  
 zWorkingSet.addcCs�t|�ddd�}i}i}g}t�}	t�t�} 
 �xL|�r||�d�}||krLq2|        �||�sZq2|�|j�}|dk�r|j        �|j�}|dks�||kr�|r�|} |dkr�|dkr�t 
 |j�}nt 
 g�}tg�} |j || ||d�}||j<|dkr�| 
 �|d�}t||��|�|�||k�r(| 
 |}t||��|��|�|j�ddd�}|�|�x(|D] }| 
 |�|j�|j|        |<�qNWd||<q2W|S)a�List all distributions needed to (recursively) meet `requirements` 
  
         `requirements` must be a sequence of ``Requirement`` objects.  `env`, 
         if supplied, should be an ``Environment`` instance.  If 
         not supplied, it defaults to all distributions available within any 
         entry or distribution in the working set.  `installer`, if supplied, 
         will be invoked with each requirement that cannot be met by an 
         already-installed distribution; it should return a ``Distribution`` or 
         ``None``. 
  
         Unless `replace_conflicting=True`, raises a VersionConflict exception 
         if 
         any requirements are found on the path that have the correct name but 
         the wrong version.  Otherwise, if an `installer` is supplied it will be 
         invoked to obtain the correct version of the requirement and activate 
         it. 
  
         `extras` is a list of the extras to be used with these requirements. 
         This is important because extra requirements may look like `my_req; 
         extra = "my_extra"`, which would otherwise be interpreted as a purely 
         optional requirement.  Instead, we want to be able to assert that these 
         requirements are truly required. 
         Nr�r)�replace_conflictingT)�list� 
 _ReqExtras�collections�defaultdict�set�pop�markers_passr�r6r�rbr�rc� 
 best_matchrjr�rir�r�extras�extendr��project_name)r��requirements�env�	installerrr�	processed�best�to_activate� 
 req_extrasr�r�r�r�r�� dependent_req�new_requirements�new_requirementrrrr��sN 
  
  
  
  
  
  
  
  
 zWorkingSet.resolvecCst|�}|��i}i}|dkr4t|j�}||7}n||}|�g�}	tt|	j|��x�|D]�} 
 x�|| 
 D]x}|��g}y|        �|||�} Wn4t        k 
 r�}z|||<|r�wjnPWdd}~XYqjXtt|	j| ��|� 
 t�| ��PqjWq\Wt|�}|��||fS)asFind all activatable distributions in `plugin_env` 
  
         Example usage:: 
  
             distributions, errors = working_set.find_plugins( 
                 Environment(plugin_dirlist) 
             ) 
             # add plugins+libs to sys.path 
             map(working_set.add, distributions) 
             # display errors 
             print('Could not load', errors) 
  
         The `plugin_env` should be an ``Environment`` instance that contains 
         only distributions that are in the project's "plugin directory" or 
         directories. The `full_env`, if supplied, should be an ``Environment`` 
         contains all currently-available distributions.  If `full_env` is not 
         supplied, one is created automatically from the ``WorkingSet`` this 
         method is called on, which will typically mean that every directory on 
         ``sys.path`` will be scanned for distributions. 
  
         `installer` is a standard installer callback as used by the 
         ``resolve()`` method. The `fallback` flag indicates whether we should 
         attempt to resolve older versions of a plugin if the newest version 
         cannot be resolved. 
  
         This method returns a 2-tuple: (`distributions`, `error_info`), where 
         `distributions` is a list of the distributions found in `plugin_env` 
         that were loadable, along with any other distributions that are needed 
         to resolve their dependencies.  `error_info` is a dictionary mapping 
         unloadable plugin distributions to an exception instance describing the 
         error that occurred. Usually this will be a ``DistributionNotFound`` or 
         ``VersionConflict`` instance. 
 N) r �sortrbr�r�rr��as_requirementr�rhr#r%r&)r�� 
 plugin_env�full_envr�fallback�plugin_projects� 
 error_info� distributionsr� 
 shadow_setrr�r��	resolveesr rrr�find_plugins's4$ 
  
  
  
  
  
 zWorkingSet.find_pluginscGs*|�t|��}x|D]}|�|�qW|S)a�Ensure that distributions matching `requirements` are activated 
  
         `requirements` must be a string or a (possibly-nested) sequence 
         thereof, specifying the distributions and versions required.  The 
         return value is a sequence of the distributions that needed to be 
         activated to fulfill the requirements; all relevant distributions are 
         included, even if they were already activated in this working set. 
 )r�rmr�)r�r�neededr�rrrrM{s	 
 zWorkingSet.requirecCs<||jkrdS|j�|�|s"dSx|D]}||�q(WdS)z�Invoke `callback` for all distributions 
  
         If `existing=True` (default), 
         call on all existing ones, as well. 
 N)r�r�)r��callback�existingr�rrr�	subscribe�s 
  
 zWorkingSet.subscribecCsx|jD]}||�qWdS)N)r�)r�r�r.rrrr�szWorkingSet.added_newcCs,|jdd�|j��|j��|jdd�fS)N)r�r�r2r�r�)r�rrrr/�szWorkingSet.getstatecCs@|\}}}}|dd�||��||��||dd�|_dS)N)r�r2r�r�r�)r��e_k_b_cr�r 
 r�r�rrrr1�s 
  
  
 zWorkingSet._setstate_)N)N)NTF)NNFN)NNT)T)rrrrr��classmethodr�r�r�r�r�rTrNrr�r�r,rMr0rr/r1rrrrrc)s& 
   
  
  
 \ 
 S 
 c@seZdZdZddd�ZdS)rz> 
     Map each requirement to the extras that demanded it. 
 Ncs2�fdd�|��d�|pdD�}�jp0t|�S)z� 
         Evaluate markers for req against each extra that 
         demanded it. 
  
         Return False if the req has a marker and fails 
         evaluation. Otherwise, return True. 
 c3s|]}�j�d|i�VqdS)�extraN)�marker�evaluate)rr3)r�rrr�sz*_ReqExtras.markers_pass.<locals>.<genexpr>r)N)r�r4�any)r�r�r�extra_evalsr)r�rr�s	 
 z_ReqExtras.markers_pass)N)rrrrrrrrrr�src@sxeZdZdZde�efdd�Zdd�Zdd�Zdd	d 
 �Z        dd�Z 
 d d�Zddd�Zddd�Z dd�Zdd�Zdd�ZdS)rbz5Searchable snapshot of distributions on a search pathNcCs i|||||_|�|�dS)a!Snapshot distributions available on a search path 
  
         Any distributions found on `search_path` are added to the environment. 
         `search_path` should be a sequence of ``sys.path`` items.  If not 
         supplied, ``sys.path`` is used. 
  
         `platform` is an optional string specifying the name of the platform 
         that platform-specific distributions must be compatible with.  If 
         unspecified, it defaults to the current platform.  `python` is an 
         optional string naming the desired version of Python (e.g. ``'3.6'``); 
         it defaults to the current version. 
  
         You may explicitly set `platform` (and/or `python`) to ``None`` if you 
         wish to map all distributions, not just those compatible with the 
         running platform or Python version. 
 N)�distmaprE�python�scan)r��search_pathrEr9rrrr��szEnvironment.init_cCs2|jdkp|jdkp|j|jk}|o0t|j|j�S)z�Is distribution `dist` acceptable for this environment? 
  
         The distribution must match the platform and python version 
         requirements specified when this environment was created, or False 
         is returned. 
         N)r9� 
 py_versionrqrE)r�r��	py_compatrrr�can_add�s 
  
 zEnvironment.can_addcCs|j|j�|�dS)z"Remove `dist` from the environmentN)r8r6�remove)r�r�rrrr?�szEnvironment.removecCs<|dkrtj}x(|D] }xt|�D]}|�|�q"WqWdS)adScan `search_path` for distributions usable in this environment 
  
         Any distributions found are added to the environment. 
         `search_path` should be a sequence of ``sys.path`` items.  If not 
         supplied, ``sys.path`` is used.  Only distributions conforming to 
         the platform/python version defined at initialization are added. 
 N)rDr�r^r�)r�r;rr�rrrr:�s 
  
 zEnvironment.scancCs|��}|j�|g�S)aReturn a newest-to-oldest list of distributions for `project_name` 
  
         Uses case-insensitive `project_name` comparison, assuming all the 
         project's distributions use their project's name converted to all 
         lowercase as their key. 
  
 )�lowerr8r�)r�r�distribution_keyrrr�_getitem�szEnvironment.getitem_cCsL|�|�rH|��rH|j�|jg�}||krH|�|�|jt�d�dd�dS)zLAdd `dist` if we ``can_add()`` it and it has not already been added 
 �hashcmpT)r6�reverseN)	r>�has_versionr8r�r6r�r"�operator� 
 attrgetter)r�r�r�rrrr�s 
  
 zEnvironment.addFcCsfy|�|�}Wntk 
 r,|s$�d}YnX|dk	r:|Sx||jD]}||krF|SqFW|�||�S)a�Find distribution best matching `req` and usable on `working_set` 
  
         This calls the ``find(req)`` method of the `working_set` to see if a 
         suitable distribution is already active.  (This may raise 
         ``VersionConflict`` if an unsuitable version of the project is already 
         active in the specified `working_set`.)  If a suitable distribution 
         isn't active, this method returns the newest distribution in the 
         environment that meets the ``Requirement`` in `req`.  If no suitable 
         distribution is found, and `installer` is supplied, then the result of 
         calling the environment's ``obtain(req, installer)`` method will be 
         returned. 
 N)r�rir6�obtain)r�r�r\rrr�rrrrs 
 zEnvironment.best_matchcCs|dk	r||�SdS)a�Obtain a distribution matching `requirement` (e.g. via download) 
  
         Obtain a distro that matches requirement (e.g. via download).  In the 
         base ``Environment`` class, this routine just returns 
         ``installer(requirement)``, unless `installer` is None, in which case 
         None is returned instead.  This method is a hook that allows subclasses 
         to attempt other ways of obtaining a distribution before falling back 
 to the `installer` argument.Nr)r��requirementrrrrrH+s	zEnvironment.obtainccs&x |j��D]}||r|VqWdS)z=Yield the unique project names of the available distributionsN)r8r 
 )r�r6rrrr7szEnvironment._itercCs^t|t�r|�|�nDt|t�rLx8|D] }x||D]}|�|�q4Wq&Wntd|f��|S)z2In-place addition of a distribution or environmentzCan't add %r to environment)r�rer�rbr�)r��other�projectr�rrr�iadd_=s 
  
  
 zEnvironment._iaddcCs.|jgddd�}x||fD]}||7}qW|S)z4Add an environment or distribution to an environmentN)rEr9)r�)r�rJ�newrrrr�addIszEnvironment.add_)N)NF)N)rrrrrL�PY_MAJORr�r>r?r:rBr�rrHrrLrNrrrrrb�s 
  
  
  
 c@seZdZdZdS)rlaTAn error occurred extracting a resource 
  
     The following attributes are available from instances of this exception: 
  
     manager 
         The resource manager that raised this exception 
  
     cache_path 
         The base directory for resource extraction 
  
     original_error 
         The exception instance that caused extraction to fail 
 N)rrrrrrrrrlUs c@s�eZdZdZdZdd�Zdd�Zdd�Zd	d 
 �Zdd�Z        d d�Z 
 dd�Zdd�Zddd�Z edd��Zdd�Zdd�Zd dd�ZdS)!rdz'Manage resource extraction and packagesNcCs 
 i|dS)N)�cached_files)r�rrrr�iszResourceManager.initcCst|��|�S)zDoes the named resource exist?)rOr�)r��package_or_requirementr�rrrrYlszResourceManager.resource_existscCst|��|�S)z,Is the named resource an existing directory?)rOrZ)r�rQr�rrrrZpszResourceManager.resource_isdircCst|��||�S)z4Return a true filesystem path for specified resource)rOr�)r�rQr�rrrrWvsz!ResourceManager.resource_filenamecCst|��||�S)z9Return a readable file-like object for specified resource)rOr�)r�rQr�rrrrV|szResourceManager.resource_streamcCst|��||�S)z%Return specified resource as a string)rOr�)r�rQr�rrrrU�szResourceManager.resource_stringcCst|��|�S)z1List the contents of the named resource directory)rOrX)r�rQr�rrrrX�sz ResourceManager.resource_listdircCsRt��d}|jpt�}t�d���}t|jft	���}|| 
 |||||�dS)z5Give an error message for problems extracting file(s)ra 
             Can't extract file(s) to egg cache 
  
             The following error occurred while trying to extract file(s) 
             to the Python egg cache: 
  
               {old_exc} 
  
             The Python egg cache directory is currently set to: 
  
               {cache_path} 
  
             Perhaps your account does not have write access to this directory? 
             You can change the cache directory by setting the PYTHON_EGG_CACHE 
             environment variable to point to an accessible directory. 
 N) rD�exc_info�extraction_pathra�textwrap�dedent�lstriprlr�r�r�� 
 cache_path�original_error)r��old_excrW�tmpl�errrrr�extraction_error�s 
 z ResourceManager.extraction_errorrcCsf|jp 
 t�}tjj||df|��}yt|�Wntk 
 rL|��YnX|�|�d|j	|<|S)a�Return absolute location in cache for `archive_name` and `names` 
  
         The parent directory of the resulting path will be created if it does 
         not already exist.  `archive_name` should be the base filename of the 
         enclosing egg (which may not be the name of the enclosing zipfile!), 
         including its ".egg" extension.  `names`, if provided, should be a 
         sequence of path name parts "under" the egg's extraction location. 
  
         This method should only be called by resource providers that need to 
         obtain an extraction location, and only for names they intend to 
         extract, as it tracks the generated names for possible cleanup later. 
         z-tmpr) 
 rSrar�r�rF�_bypass_ensure_directory�	Exceptionr\�_warn_unsafe_extraction_pathrP)r��archive_name�names�extract_path�target_pathrrr�get_cache_path�s  
  
 zResourceManager.get_cache_pathcCsVtjdkr|�tjd�sdSt�|�j}|tj@s>|tj@rRd|}t�	|t 
 �dS)aN 
         If the default extraction path is overridden and set to an insecure 
         location, such as /tmp, it opens up an opportunity for an attacker to 
         replace an extracted file with an unauthorized payload. Warn the user 
         if a known insecure location is used. 
  
         See Distribute #375 for more details. 
 �nt�windirNz�%s is writable by group/others and vulnerable to attack when used with get_resource_filename. Consider a more secure location (set with .set_extraction_path or the PYTHON_EGG_CACHE environment variable).)r�r�r��environ�stat�st_mode�S_IWOTH�S_IWGRP�warnings�warn�UserWarning)r��mode�msgrrrr_�s 
 z,ResourceManager._warn_unsafe_extraction_pathcCs.tjdkr*t�|�jdBd@}t�||�dS)a4Perform any platform-specific postprocessing of `tempname` 
  
         This is where Mac header rewrites should be done; other platforms don't 
         have anything special they should do. 
  
         Resource providers should call this method ONLY after successfully 
         extracting a compressed resource.  They must NOT call it on resources 
         that are already in the filesystem. 
  
         `tempname` is the current (temporary) name of the file, and `filename` 
         is the name it will be renamed to by the caller after this routine 
         returns. 
 �posiximi�N)r�r�rhri�chmod)r��tempname�filenamerorrr�postprocess�s 
 zResourceManager.postprocesscCs|jrtd��||_dS)a�Set the base path where resources will be extracted to, if needed. 
  
         If you do not call this routine before any extractions take place, the 
         path defaults to the return value of ``get_default_cache()``.  (Which 
         is based on the ``PYTHON_EGG_CACHE`` environment variable, with various 
         platform-specific fallbacks.  See that routine's documentation for more 
         details.) 
  
         Resources are extracted to subdirectories of this path based upon 
         information given by the ``IResourceProvider``.  You may set this to a 
         temporary directory, but then you must call ``cleanup_resources()`` to 
         delete the extracted files when done.  There is no guarantee that 
         ``cleanup_resources()`` will be able to remove all extracted files. 
  
         (Note: you may not change the extraction path for a given resource 
         manager once resources have been extracted, unless you first call 
         ``cleanup_resources()``.) 
 z5Can't change extraction path, files already extractedN)rPrIrS)r�r�rrrr_�sz#ResourceManager.set_extraction_pathFcCsdS)aB 
         Delete all extracted resource files and directories, returning a list 
         of the file and directory names that could not be successfully removed. 
         This function does not have any concurrency protection, so it should 
         generally only be called when the extraction path is a temporary 
         directory exclusive to a single process.  This method is not 
         automatically called; you must call it explicitly or register it as an 
         ``atexit`` function if you wish to ensure cleanup of a temporary 
         directory used for extractions. 
 Nr)r��forcerrrr`s 
 z!ResourceManager.cleanup_resources)r)F)rrrrrSr�rYrZrWrVrUrXr\rd�staticmethodr_rur_r`rrrrrdes 
 cCstj�d�ptjdd�S)z� 
     Return the ``PYTHON_EGG_CACHE`` environment variable 
     or a platform-relevant user cache dir for an app 
     named "Python-Eggs". 
 �PYTHON_EGG_CACHEzPython-Eggs)�appname)r�rgr�r�user_cache_dirrrrrrascCst�dd|�S)z�Convert an arbitrary string to a standard distribution name 
  
     Any runs of non-alphanumeric/. characters are replaced with a single '-'. 
 z[^A-Za-z0-9.]+�-)�re�sub)r�rrrrn%scCsDyttj�|��Stjjk 
 r>|�dd�}t�dd|�SXdS)zB 
     Convert an arbitrary string to a standard version string 
 r�r?z[^A-Za-z0-9.]+r{N)r�rrrrr�r|r})rrrrro-s 
 cCst�dd|���S)z�Convert an arbitrary string to a standard 'extra' name 
  
     Any runs of non-alphanumeric characters are replaced with a single '_', 
     and the result is always lowercased. 
 z[^A-Za-z0-9.-]+r�)r|r}r@)r3rrrrt9scCs|�dd�S)z|Convert a project or version name to its filename-escaped form 
  
     Any '-' characters are currently replaced with '_'. 
 r{r�)r�)r�rrrruBsc 
 Cs@yt|�Wn.tk 
 r:}zd|d||Sd}~XYnXdS)zo 
     Validate text as a PEP 508 environment marker; return an exception 
     if invalid or False otherwise. 
 NF)rw�SyntaxErrorrt�lineno)�text�errrrvJsc 
 CsHytj�|�}|��Stjjk 
 rB}zt|��Wdd}~XYnXdS)z� 
     Evaluate a PEP 508 environment marker. 
     Return a boolean indicating the marker result in this environment. 
     Raise SyntaxError if marker is invalid. 
  
     This implementation uses the 'pyparsing' module. 
 N)r�markers�Markerr5� InvalidMarkerr~)r�r3r4r�rrrrwXs 
 c@s�eZdZdZdZdZdZdd�Zdd�Zdd�Z	d	d 
 �Z 
 dd�Zd d�Zdd�Z dd�Zdd�Zdd�Zdd�Zdd�Zdd�Zdd�Zdd �Zd!d"�Zd#d$�Zd%d&�Zed'd(��Zd)d*�ZdS)+r�zETry to implement resources and metadata for arbitrary PEP 302 loadersNcCs(t|dd�|tj�t|dd��|_dS)Nr��filer�)r�r�r�r��dirname�module_path)r�r�rrrr�nszNullProvider.init_cCs|�|j|�S)N)�_fnr�)r�r�r�rrrr�rsz"NullProvider.get_resource_filenamecCst�|�||��S)N)�io�BytesIOr�)r�r�r�rrrr�usz NullProvider.get_resource_streamcCs|�|�|j|��S)N)�_getr�r�)r�r�r�rrrr�xsz NullProvider.get_resource_stringcCs|�|�|j|��S)N)�_hasr�r�)r�r�rrrr�{szNullProvider.has_resourcecCs|�|j|�S)N)r��egg_info)r�r�rrr�_get_metadata_path~szNullProvider._get_metadata_pathcCs |js|jS|�|�}|�|�S)N)r�r�r�)r�r�r�rrrr��s 
 zNullProvider.has_metadatac 
 Csr|js 
 dS|�|�}|�|�}tjr(|Sy 
 |�d�Stk 
 rl}z|jd�||�7_�Wdd}~XYnXdS)Nr�zutf-8z in {} file at path: {})	r�r�r�r�PY2�decode�UnicodeDecodeError�reasonr�)r�r�r��value�excrrrr��s 
  
  
 zNullProvider.get_metadatacCst|�|��S)N)rrr�)r�r�rrrr��szNullProvider.get_metadata_linescCs|�|�|j|��S)N)�_isdirr�r�)r�r�rrrrZ�szNullProvider.resource_isdircCs|jo|�|�|j|��S)N)r�r�r�)r�r�rrrr��szNullProvider.metadata_isdircCs|�|�|j|��S)N)�_listdirr�r�)r�r�rrrrX�szNullProvider.resource_listdircCs|jr|�|�|j|��SgS)N)r�r�r�)r�r�rrrr��szNullProvider.metadata_listdirc 
 Cs�d|}|�|�s$tdjft����|�|��dd�}|�dd�}|�|j|�}||d<tj	� 
 |�r�t|���}t ||d�}t|||�n>dd        lm}t|�d|�d�|f||<t ||d�}        t|        ||�dS) 
 Nzscripts/z<Script {script!r} not found in metadata at {self.egg_info!r}z  
 � 
 � r��execr)�cache)r�rhr�r�r�r�r�r�r�r�r�r�read�compiler��	linecacher��lenr) 
 r�r�r��script�script_text�script_filename�source�coder��script_coderrrrN�s" 
  
 zNullProvider.run_scriptcCstd��dS)Nz9Can't perform this operation for unregistered loader type)�NotImplementedError)r�r�rrrr��szNullProvider._hascCstd��dS)Nz9Can't perform this operation for unregistered loader type)r�)r�r�rrrr��szNullProvider._isdircCstd��dS)Nz9Can't perform this operation for unregistered loader type)r�)r�r�rrrr��szNullProvider._listdircCs*|�|�|r&tjj|f|�d���S|S)N�/)�_validate_resource_pathr�r�rFr)r��baser�rrrr��s 
 zNullProvider._fncCsptjj|�tj�kp&t�|�p&t�|�}|s0dSd}t�|�rPt�|�sPt|��t	j 
 |dd�dtdd�dS)aO 
         Validate the resource paths according to the docs. 
         https://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access 
  
         >>> warned = getfixture('recwarn') 
         >>> warnings.simplefilter('always') 
         >>> vrp = NullProvider._validate_resource_path 
         >>> vrp('foo/bar.txt') 
         >>> bool(warned) 
         False 
         >>> vrp('../foo/bar.txt') 
         >>> bool(warned) 
         True 
         >>> warned.clear() 
         >>> vrp('/foo/bar.txt') 
         >>> bool(warned) 
         True 
         >>> vrp('foo/../../bar.txt') 
         >>> bool(warned) 
         True 
         >>> warned.clear() 
         >>> vrp('foo/f../bar.txt') 
         >>> bool(warned) 
         False 
  
         Windows path separators are straight-up disallowed. 
         >>> vrp(r'\foo/bar.txt') 
         Traceback (most recent call last): 
         ... 
         ValueError: Use of .. or absolute path in a resource path is not allowed. 
  
         >>> vrp(r'C:\foo/bar.txt') 
         Traceback (most recent call last): 
         ... 
         ValueError: Use of .. or absolute path in a resource path is not allowed. 
  
         Blank values are allowed 
  
         >>> vrp('') 
         >>> bool(warned) 
         False 
  
         Non-string values are not. 
  
         >>> vrp(None) 
         Traceback (most recent call last): 
         ... 
         AttributeError: ... 
         Nz=Use of .. or absolute path in a resource path is not allowed.r�z/ and will raise exceptions in a future release.r)� 
 stacklevel)r�r��pardirr�	posixpath�sep�isabs�ntpathrIrlrm�DeprecationWarning)r��invalidrprrrr��s6 
  
 z$NullProvider.validate_resource_pathcCs$t|jd�r|j�|�Std��dS)N�get_dataz=Can't perform this operation for loaders without 'get_data()')r�r�r�r�)r�r�rrrr�szNullProvider._get)rrrr�egg_namer�r�r�r�r�r�r�r�r�r�r�rZr�rXr�rNr�r�r�r�rwr�r�rrrrr�gs0Kc@s eZdZdZdd�Zdd�ZdS)r�z&Provider based on a virtual filesystemcCst�||�|��dS)N)r�r�� _setup_prefix)r�r�rrrr�-szEggProvider.initcCs^|j}d}xN||krXt|�rBtj�|�|_tj�|d�|||_P|}tj�	|�\}}qWdS)NzEGG-INFO) 
 r��_is_egg_pathr�r��basenamer�rFr��egg_rootr)r�r��oldr�rrrr�1s 
 zEggProvider._setup_prefixN)rrrrr�r�rrrrr�*sc@sDeZdZdZdd�Zdd�Zdd�Zdd	�Zd 
 d�Ze        dd ��Z 
 dS)r�z6Provides access to package resources in the filesystemcCstj�|�S)N)r�r�r�)r�r�rrrr�CszDefaultProvider._hascCstj�|�S)N)r�r�r )r�r�rrrr�FszDefaultProvider._isdircCs 
 t�|�S)N)r��listdir)r�r�rrrr�IszDefaultProvider._listdircCst|�|j|�d�S)N�rb)rr�r�)r�r�r�rrrr�Lsz#DefaultProvider.get_resource_streamc	Cst|d�� 
 }|��SQRXdS)Nr�)rr�)r�r��streamrrrr�OszDefaultProvider._getcCs0d}x&|D]}tt|td��}t||�q 
 WdS)N)�SourceFileLoader�SourcelessFileLoader)r��importlib_machinery�typer�)r��loader_namesr�� 
 loader_clsrrr�	_registerSs 
 zDefaultProvider._registerN)rrrrr�r�r�r�r�r2r�rrrrr�@sc@s8eZdZdZdZdd�ZZdd�Zdd�Zd	d 
 �Z	dS)r�z.Provider that returns nothing for all requestsNcCsdS)NFr)r�r�rrrr<cr=zEmptyProvider.<lambda>cCsdS)Nr�r)r�r�rrrr�eszEmptyProvider.getcCsgS)Nr)r�r�rrrr�hszEmptyProvider._listdircCsdS)Nr)r�rrrr�kszEmptyProvider.init_) 
 rrrrr�r�r�r�r�r�rrrrr�^sc@s eZdZdZedd��ZeZdS)�ZipManifestsz 
     zip manifest builder 
 c	s4t�|�� ��fdd����D�}t|�SQRXdS)a 
         Build a dictionary similar to the zipimport directory 
         caches, except instead of tuples, store ZipInfo objects. 
  
         Use a platform-specific path separator (os.sep) for the path keys 
         for compatibility with pypy on Windows. 
 c3s&|]}|�dtj���|�fVqdS)r�N)r�r�r��getinfo)rr�)�zfilerrr�sz%ZipManifests.build.<locals>.<genexpr>N)�zipfile�ZipFile�namelistr%)r�r�r+r)r�r�buildws	 
 zZipManifests.buildN)rrrrr2r��loadrrrrr�rsr�c@s$eZdZdZe�dd�Zdd�ZdS)�MemoizedZipManifestsz% 
     Memoized zipfile manifests. 
 �manifest_modzmanifest mtimecCsRtj�|�}t�|�j}||ks.||j|krH|�|�}|�||�||<||jS)zW 
         Load a manifest at path or return a suitable manifest already loaded. 
 )	r�r��normpathrh�st_mtime�mtimer�r��manifest)r�r�r�r�rrrr��s 
 zMemoizedZipManifests.loadN)rrrrr� 
 namedtupler�r�rrrrr��sr�c@s�eZdZdZdZe�Zdd�Zdd�Zdd�Z	e 
 d        d 
 ��Zdd�Ze d d��Zdd�Zdd�Zdd�Zdd�Zdd�Zdd�Zdd�Zdd�Zdd �ZdS)!r�z"Resource support for zips and eggsNcCs t�||�|jjtj|dS)N)r�r�r��archiver�r��zip_pre)r�r�rrrr��szZipProvider.init_cCsP|�tj�}||jjkrdS|�|j�r:|t|j�d�Std||jf��dS)Nr�z%s is not a subpath of %s)	�rstripr�r�r�r�r�r�r��AssertionError)r��fspathrrr� _zipinfo_name�szZipProvider._zipinfo_namecCsP|j|}|�|jtj�r:|t|j�dd��tj�Std||jf��dS)Nrz%s is not a subpath of %s)r�r�r�r�r�r�rr�)r��zip_pathr�rrr�_parts�s 
  
 zZipProvider._partscCs|j�|jj�S)N)�_zip_manifestsr�r�r�)r�rrr�zipinfo�szZipProvider.zipinfocCs`|jstd��|�|�}|��}d�|�|��|krTx|D]}|�||�|��q:W|�||�S)Nz5resource_filename() only supported for .egg, not .zipr�)r�r��_resource_to_zip�_get_eager_resourcesrFr��_extract_resource� _eager_to_zip)r�r�r�r��eagersr�rrrr��s 
  
 z!ZipProvider.get_resource_filenamecCs"|j}|jd}t�|�}||fS)N)rrr�)�	file_size�	date_time�time�mktime)�zip_stat�sizer��	timestamprrr�_get_date_and_size�s 
  
 zZipProvider._get_date_and_sizec 
 Csn||��krDx*|��|D]}|�|tj�||��}qWtj�|�S|�|j|�\}}tsdt	d��y�|� 
 |j|�|��}|� ||�r�|Stdtj�|�d�\}}	t�||j�|��t�|�t|	||f�|�|	|�yt|	|�Wn\tjk 
 �rDtj�|��r>|� ||��r|Stjdk�r>t|�t|	|�|S�YnXWn tjk 
 �rh|��YnX|S)Nz>"os.rename" and "os.unlink" are not supported on this platformz	.$extract)�dirre)�_indexr�r�r�rFr�r�r�� WRITE_SUPPORT�IOErrorrdr�r��_is_current�_mkstemp�writer�r��closerrur 
 �error�isfiler�rr\) 
 r�r�r�r��lastr�r��	real_path�outf�tmpnamrrrr��sD 
  
 zZipProvider._extract_resourcec		Csx|�|j|�\}}tj�|�s$dSt�|�}|j|ksB|j|krFdS|j�	|�}t 
 |d��}|��}WdQRX||kS)zK 
         Return True if the file_path is current for this zip_path 
 Fr�N)r�r�r�r�r�rh�st_sizer�r�r�rr�)	r��	file_pathr�r�r�rh�zip_contents�f� file_contentsrrrr�s 
 zZipProvider.is_currentcCsB|jdkr<g}x&dD]}|�|�r|�|�|��qW|||jS)N)znative_libs.txtzeager_resources.txt)r�r�rr�)r�r�r�rrrr�"s 
  
  
 z ZipProvider._get_eager_resourcesc	Cs�y|jStk 
 r�i}xd|jD]Z}|�tj�}xH|rztj�|dd��}||krj||�|d�Pq4|��g||<q4Wq"W||_|SXdS)Nr�)	�	_dirindex�AttributeErrorr�rr�r�rFr�r)r��indr��parts�parentrrrr�+szZipProvider._indexcCs |�|�}||jkp||��kS)N)r�r�r�)r�r�r�rrrr�<s 
 zZipProvider._hascCs|�|�|��kS)N)r�r�)r�r�rrrr�@szZipProvider._isdircCst|���|�|�d��S)Nr)r r�r�r�)r�r�rrrr�CszZipProvider._listdircCs|�|�|j|��S)N)r�r�r�)r�r�rrrr�FszZipProvider._eager_to_zipcCs|�|�|j|��S)N)r�r�r�)r�r�rrrr�IszZipProvider._resource_to_zip)rrrrr�r�r�r�r�r�r�r�r�rwr�r�r�r�r�r�r�r�r�r�rrrrr��s$ 
 	7	c@s@eZdZdZdd�Zdd�Zdd�Zdd	�Zd 
 d�Zdd �Z        dS)r�a*Metadata handler for standalone PKG-INFO files 
  
     Usage:: 
  
         metadata = FileMetadata("/path/to/PKG-INFO") 
  
     This provider rejects all data and metadata requests except for PKG-INFO, 
     which is treated as existing, and will be the contents of the file at 
     the provided location. 
 cCs 
 ||dS)N)r�)r�r�rrrr�\szFileMetadata.init_cCs|jS)N)r�)r�r�rrrr�_szFileMetadata._get_metadata_pathcCs|dkotj�|j�S)NzPKG-INFO)r�r�r�)r�r�rrrr�bszFileMetadata.has_metadatac	CsD|dkrtd��tj|jddd��}|��}WdQRX|�|�|S)NzPKG-INFOz(No metadata except PKG-INFO is availablezutf-8r�)�encoding�errors)r�r�rr�r��_warn_on_replacement)r�r�r��metadatarrrr�es 
 zFileMetadata.get_metadatacCs2d�d�}||kr.d}|jft��}t�|�dS)Ns�zutf-8z2{self.path} could not be properly decoded in UTF-8)r�r�r�rlrm)r�r�replacement_charrZrprrrrns 
  
 z!FileMetadata._warn_on_replacementcCst|�|��S)N)rrr�)r�r�rrrr�vszFileMetadata.get_metadata_linesN) 
 rrrrr�r�r�r�rr�rrrrr�Ps 
 	c@seZdZdZdd�ZdS)r�asMetadata provider for egg directories 
  
     Usage:: 
  
         # Development eggs: 
  
         egg_info = "/path/to/PackageName.egg-info" 
         base_dir = os.path.dirname(egg_info) 
         metadata = PathMetadata(base_dir, egg_info) 
         dist_name = os.path.splitext(os.path.basename(egg_info))[0] 
         dist = Distribution(basedir, project_name=dist_name, metadata=metadata) 
  
         # Unpacked egg directories: 
  
         egg_path = "/path/to/PackageName-ver-pyver-etc.egg" 
         metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO')) 
         dist = Distribution.from_filename(egg_path, metadata=metadata) 
 cCs||||_dS)N)r�r�)r�r�r�rrrr��szPathMetadata.initN)rrrrr�rrrrr�zsc@seZdZdZdd�ZdS)r�z Metadata provider for .egg filescCsD|jtj||||jr0tj�|j|j�|_n|j||�	�dS)z-Create a metadata provider from a zipimporterN) 
 r�r�r�r�r��prefixr�rFr�r�)r��importerrrrr��szEggMetadata._init_N)rrrrr�rrrrr��sr%)�_distribution_finderscCs|t|<dS)axRegister `distribution_finder` to find distributions in sys.path items 
  
     `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item 
     handler), and `distribution_finder` is a callable that, passed a path 
     item and the importer instance, yields ``Distribution`` instances found on 
 that path item. See ``pkg_resources.find_on_path`` for an example.N)r)� importer_type�distribution_finderrrrr��scCst|�}tt|�}||||�S)z.Yield distributions accessible via `path_item`)rr�r)�	path_item�onlyr�finderrrrr^�s 
 c	cs�|j�d�rdSt|�}|�d�r2tj||d�V|r:dSx�|�d�D]�}t|�r�tj	� 
 ||�}tt� |�|�}xT|D] 
 }|VqvWqF|���d�rFtj        � 
 ||�}tt� |��}||_t�|||�VqFWdS)z@ 
     Find eggs in zip files; possibly multiple nested eggs. 
     z.whlNzPKG-INFO)rr�z 
 .dist-info)r��endswithr�r�re� from_filenamerXr�r�r�rF�find_eggs_in_zip�	zipimport�zipimporterr@r�� from_location)	rr 
 rr�subitem�subpathr�r��submetarrrr�s$ 
  
 rcCsdS)Nrr)rr 
 rrrr�find_nothing�srcCsdd�}t||dd�S)aL 
     Given a list of filenames, return them in descending order 
     by version number. 
  
     >>> names = 'bar', 'foo', 'Python-2.7.10.egg', 'Python-2.7.2.egg' 
     >>> _by_version_descending(names) 
     ['Python-2.7.10.egg', 'Python-2.7.2.egg', 'foo', 'bar'] 
     >>> names = 'Setuptools-1.2.3b1.egg', 'Setuptools-1.2.3.egg' 
     >>> _by_version_descending(names) 
     ['Setuptools-1.2.3.egg', 'Setuptools-1.2.3b1.egg'] 
     >>> names = 'Setuptools-1.2.3b1.egg', 'Setuptools-1.2.3.post1.egg' 
     >>> _by_version_descending(names) 
     ['Setuptools-1.2.3.post1.egg', 'Setuptools-1.2.3b1.egg'] 
 cSs2tj�|�\}}t�|�d�|g�}dd�|D�S)z6 
         Parse each component of the filename 
 r{cSsg|]}tj�|��qSr)rrr�)r�partrrr� 
 <listcomp>�sz?_by_version_descending.<locals>._by_version.<locals>.<listcomp>)r�r��splitext�	itertools�chainr)r��extr�rrr�_by_version�sz+_by_version_descending.<locals>._by_versionT)r6rD)�sorted)rarrrr�_by_version_descending�src 
 #s�t���t��r4tj�t�tj��d��d�VdSt��}��fdd�|D�}t	|�}x>|D]6}tj��|�}t 
 �|��}x||�D] 
 }	|	Vq�Wq^WdS)z6Yield distributions accessible on a sys.path directoryzEGG-INFO)rNc3s|]}t�|��r|VqdS)N)�dist_factory)rr�)rr 
 rrrszfind_on_path.<locals>.<genexpr>)�_normalize_cached�_is_unpacked_eggrerr�r�r�rF�safe_listdirrr ) 
 rr 
 rr��filtered�path_item_entriesr��fullpath�factoryr�r)rr 
 r�find_on_path�s 
 r(cCsH|��}tt|jd��}|r tS|s0t|�r0tS|sB|�d�rBtSt�S)z9 
     Return a dist_factory for a path_item and entry 
     )z        .egg-infoz 
 .dist-infoz	.egg-link)	r@r6rr �distributions_from_metadatar�r^�resolve_egg_link�NoDists)r 
 r�rr@�is_metarrrr sr c@s*eZdZdZdd�ZejreZdd�ZdS)r+zS 
     >>> bool(NoDists()) 
     False 
  
     >>> list(NoDists()('anything')) 
     [] 
 cCsdS)NFr)r�rrr�_bool.szNoDists.boolcCstd�S)Nr)�iter)r�r&rrr�call3szNoDists.callN)	rrrrr-rr��nonzero_r/rrrrr+&s 
 r+c 
 Csty 
 t�|�Sttfk 
 r"YnNtk 
 rn}z0|jtjtjtjfkpVt        |dd�dk}|s^�Wdd}~XYnXdS)zI 
     Attempt to list contents of path, but suppress some exceptions. 
     �winerrorNir) 
 r�r��PermissionError�NotADirectoryError�OSError�errno�ENOTDIR�EACCES�ENOENTr�)r�r��	ignorablerrrr#7s 
 r#ccsftj�|�}tj�|�r:tt�|��dkr.dSt||�}nt|�}tj�|�}t	j 
 |||td�VdS)Nr)� 
 precedence)r�r�r�r r�r�r�r�r�rerr~)r��rootrr�rrrr)Lsr)c	cs8t|��&}x|D]}|��}|r|VqWWdQRXdS)z1 
     Yield non-empty lines from file at path 
 N)r�strip)r�r��linerrr�non_empty_lines[s 
  
  
 r>cs.t��}�fdd�|D�}tt|�}t|d�S)za 
     Given a path to an .egg-link, resolve distributions 
     present in the referenced path. 
 c3s$|]}tj�tj���|�VqdS)N)r�r�rFr�)r�ref)r�rrrmsz#resolve_egg_link.<locals>.<genexpr>r)r>rr^�next)r��referenced_paths�resolved_paths�dist_groupsr)r�rr*fs 
  
  
 r*� 
 FileFinder)�_namespace_handlers)�_namespace_packagescCs|t|<dS)a�Register `namespace_handler` to declare namespace packages 
  
     `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item 
     handler), and `namespace_handler` is a callable like this:: 
  
         def namespace_handler(importer, path_entry, moduleName, module): 
             # return a path_entry to use for child packages 
  
     Namespace handlers are only called if the importer object has already 
     agreed that it can handle the relevant path item, and they should only 
     return a subpath if the module _path_ does not already contain an 
     equivalent subpath.  For an example namespace handler, see 
     ``pkg_resources.file_ns_handler``. 
 N)rE)r�namespace_handlerrrrr�}sc	Cs�t|�}|dkrdSt���t�d�|�|�}WdQRX|dkrHdStj�|�}|dkr�t�	|�}tj|<g|_ 
 t|�nt|d�s�t d|��tt|�}|||||�}|dk        r�|j 
 }|�|�|�|�t|||�|S)zEEnsure that named package includes a subpath of path_item (if needed)N�ignore�_path_zNot a package:)rrl�catch_warnings�simplefilter�find_modulerDr�r��types� 
 ModuleTyperI�_set_parent_nsr�r�r�rEr��load_module�_rebuild_mod_path)�packageNamer 
 rr�r��handlerrr�rrr� 
 _handle_ns�s. 
  
  
  
  
  
  
  
 rTcsjdd�tjD���fdd����fdd�}t||d�}dd�|D�}t|jt�r`||jd	d	�<n||_d	S) 
 zq 
     Rebuild module._path_ ensuring that all entries are ordered 
     corresponding to their sys.path order 
 cSsg|]}t|��qSr)r!)r�prrrr�sz%_rebuild_mod_path.<locals>.<listcomp>cs(y 
 ��|�Stk 
 r"td�SXdS)z/ 
         Workaround for #520 and #513. 
 �infN)�indexrI�float)r�)�sys_pathrr�safe_sys_path_index�s 
 z._rebuild_mod_path.<locals>.safe_sys_path_indexcs<|�tj�}��d�d}|d|�}�ttj�|���S)zR 
         Return the ordinal of the path based on its position in sys.path 
 r?rN)rr�r��countr!rF)r�� 
 path_parts�module_partsr�)�package_namerZrr�position_in_sys_path�sz/rebuild_mod_path.<locals>.position_in_sys_path)r6cSsg|]}t|��qSr)r!)rrUrrrr�sN)rDr�rr�rIr )�	orig_pathr^r�r�new_pathr)r^rZrYrrQ�s		rQcCs�t��z�|tkrdStj}|�d�\}}}|rxt|�|tkrHt|�ytj|j	}Wnt 
 k 
 rvtd|��YnXt�|p�dg�� |�t�|g�x|D]}t||�q�WWdt��XdS)z9Declare that package 'packageName' is a namespace packageNr?zNot a package:)�_imp�acquire_lockrFrDr�� 
 rpartitionr[r�r�rIr�r�r�r�rT�release_lock)rRr�r�r�r 
 rrrr[�s& 
 cCsJt��z2x,t�|d�D]}t||�}|rt||�qWWdt��XdS)zDEnsure that previously-declared namespace packages include path_itemrN)rbrcrFr�rTr�re)r 
 r��packagerrrrr��s 
 cCsFtj�||�d�d�}t|�}x |jD]}t|�|kr(Pq(W|SdS)zBCompute an ns-package subpath for a filesystem or zipfile importerr?r�N)r�r�rFrr!rI)rr 
 rRr�r� 
 normalizedrrrr�file_ns_handler�srhcCsdS)Nr)rr 
 rRr�rrr�null_ns_handler	sricCs tj�tj�tj�t|����S)z1Normalize a file/dir name for comparison purposes)r�r��normcase�realpathr�� _cygwin_patch)rtrrrry	scCstjdkrtj�|�S|S)a 
     Contrary to POSIX 2008, on Cygwin, getcwd (3) contains 
     symlink components. Using 
     os.path.abspath() works around this limitation. A fix in os.getcwd() 
     would probably better, in Cygwin even more so, except 
     that this seems to be by design... 
 �cygwin)rDrEr�r��abspath)rtrrrrl	srlcCs2y||Stk 
 r,t|�||<}|SXdS)N)r�ry)rtr��resultrrrr!)	s 
 r!cCs|���d�S)z7 
     Determine if given path appears to be an egg. 
 z.egg)r@r )r�rrrr�1	sr�cCs t|�otj�tj�|dd��S)z@ 
     Determine if given path appears to be an unpacked egg. 
 zEGG-INFOzPKG-INFO)r�r�r�r�rF)r�rrrr"8	sr"cCs<|�d�}|��}|r8d�|�}ttj||tj|�dS)Nr?)rrrF�setattrrDr�)rRr�r�r�rrrrOB	s 
  
  
 rOccsft|tj�r<xT|��D] }|��}|r|�d�s|VqWn&x$|D]}xt|�D] 
 }|VqPWqBWdS)z9Yield non-empty/non-comment lines of a string or sequence�#N)r�rr�� 
 splitlinesr<r�rr)�strs�s�ssrrrrrJ	s 
 z\w+(\.\w+)*$z� 
     (?P<name>[^-]+) ( 
         -(?P<ver>[^-]+) ( 
             -py(?P<pyver>[^-]+) ( 
                 -(?P<plat>.+) 
             )? 
         )? 
     )? 
 c@s�eZdZdZddd�Zdd�Zdd	�Zddd�Zd d�Zddd�Z	e 
 �d�Ze ddd��Ze dd��Ze ddd��Ze ddd��ZdS) rgz3Object representing an advertised importable objectrNcCs<t|�std|��||||_t|�|_t|�|||_dS)NzInvalid module name)�MODULErIr��module_name�tuple�attrsrr�)r�r�rwryrr�rrrr�j	s 
  
  
 zEntryPoint._initcCsHd|j|jf}|jr*|dd�|j�7}|jrD|dd�|j�7}|S)Nz%s = %s�:r?z [%s]�,)r�rwryrFr)r�rtrrrr�s	szEntryPoint.strcCsdt|�S)NzEntryPoint.parse(%r))r�)r�rrrr�{	szEntryPoint.repr_TcOs4|r|s|rtjdtdd�|r,|j||�|��S)zH 
         Require packages for this EntryPoint, then resolve it. 
 zJParameters to load are deprecated. Call .resolve and .require separately.r@)r�)rlrmr�rMr�)r�rMr;�kwargsrrrr�~	szEntryPoint.loadc 
 CsVt|jdgdd�}yt�t|j|�Stk 
 rP}ztt|���Wdd}~XYnXdS)zD 
         Resolve the entry point from its module and attrs. 
 rr)�fromlist�levelN)	r�rw�	functools�reducer�ryr�r�r�)r�r�r�rrrr��	s 
 zEntryPoint.resolvecCsL|jr|jstd|��|j�|j�}tj||||jd�}tttj|��dS)Nz&Can't require() without a distribution)r)	rr�rkrr\r�r rr�)r�rrr�r+rrrrM�	s 
  
 zEntryPoint.requirez]\s*(?P<name>.+?)\s*=\s*(?P<module>[\w.]+)\s*(:\s*(?P<attr>[\w.]+))?\s*(?P<extras>\[.\])?\s$cCsf|j�|�}|sd}t||��|��}|�|d�}|drJ|d�d�nd}||d|d|||�S)aParse a single entry point from string `src` 
  
         Entry point syntax follows the form:: 
  
             name = some.module:some.attr [extra1, extra2] 
  
         The entry name and module name are required, but the ``:attrs`` and 
         ``[extras]`` parts are optional 
 z9EntryPoint must be in 'name=module:attrs [extras]' formatr�attrr?rr�r�)�patternrCrI�	groupdict� _parse_extrasr)r��srcr�rKrp�resrryrrrr��	s 
 zEntryPoint.parsecCs(|sdSt�d|�}|jr"t��|jS)Nr�x)rfr��specsrIr)r��extras_specr�rrrr��	szEntryPoint._parse_extrascCsZt|�std|��i}x>t|�D]2}|�||�}|j|krHtd||j��|||j<q W|S)zParse an entry point groupzInvalid group namezDuplicate entry point)rvrIrrr�r�)r�rH�linesr��thisr=�eprrr�parse_group�	s 
  
 zEntryPoint.parse_groupcCsxt|t�r|��}nt|�}i}xR|D]J\}}|dkrD|s<q&td��|��}||kr^td|��|�|||�||<q&W|S)z!Parse a map of entry point groupsNz%Entry points must be listed in groupszDuplicate group name)r�r%r+rsrIr<r�)r��datar��mapsrHr�rrr�	parse_map�	s 
  
  
 zEntryPoint.parse_map)rrN)T)NN)N)N)N)rrrrr�r�r�r�r�rMr|r�r�r2r�r�r�r�rrrrrgg	s  
          
  
  
 	cCs>|sdStj�|�}|d�d�r:tj�|dd�d�S|S)Nr�r�zmd5=)r�)rr��urlparser�� 
 urlunparse)r�parsedrrr�_remove_md5_fragment�	sr�cCs@dd�}t||�}tt|�d�}|�d�\}}}t|���p>dS)z� 
     Given an iterable of lines from a Metadata file, return 
     the value of the Version field, if present, or None otherwise. 
 cSs|���d�S)Nzversion:)r@r�)r=rrr�is_version_line�	sz+_version_from_file.<locals>.is_version_liner�rzN)rr@r.�	partitionror<)r�r�� version_linesr=r�r�rrr�_version_from_file�	s 
  
 r�cs�eZdZdZdZddddedefdd�ZedSdd��Z	dd	�Z 
 ed 
 d��Zdd �Z dd�Zdd�Zdd�Zdd�Zdd�Zdd�Zedd��Zedd��Zdd�Zed d!��Zed"d#��Zed$d%��Zd&d'�ZdTd)d*�Zd+d,�Zd-d.�Zd/d0�ZdUd2d3�Z d4d5�Z!d6d7�Z"d8d9�Z#d:d;�Z$�fd<d=�Z%e&e'd>��s4[%edVd?d@��Z(dAdB�Z)dCdD�Z*dWdEdF�Z+dGdH�Z,dXdIdJ�Z-dKdL�Z.dMdN�Z/dOdP�Z0edQdR��Z1�Z2S)Yrez5Wrap an actual or potential sys.path entry w/metadatazPKG-INFONcCsFt|pd�||dk	r t|�||||||||||p>t|_	dS)N�Unknown) 
 rnrro�_versionr<rErr:r��	_provider)r�rrrrr<rEr:rrrr� 
 s 
 zDistribution._init_cKs~dgd\}}}}tj�|�\}}	|	��tkr^t|	��}t|�} 
 | 
 r^| 
 �dddd�\}}}}|||f||||d�|����S)Nrr��ver�pyverrJ)rrr<rE)r�r�rr@�_distributionImpl�EGG_NAMErH�_reload_version)r�rr�rr(rrr<rErrCrrrr 
 s 
 zDistribution.from_locationcCs|S)Nr)r�rrrr�# 
 szDistribution._reload_versioncCs(|j|j|jt|j�|jpd|jp$dfS)Nr�)�parsed_versionr:r6r�rr<rE)r�rrrrC& 
 szDistribution.hashcmpcCs 
 t|j�S)N)�hashrC)r�rrr�_hash_1 
 szDistribution._hashcCs|j|jkS)N)rC)r�rJrrr�lt_4 
 szDistribution._ltcCs|j|jkS)N)rC)r�rJrrr�le_7 
 szDistribution._lecCs|j|jkS)N)rC)r�rJrrr�gt_: 
 szDistribution._gtcCs|j|jkS)N)rC)r�rJrrr�ge_= 
 szDistribution._gecCst||j�sdS|j|jkS)NF)r�r�rC)r�rJrrr�eq_@ 
 szDistribution._eq_cCs 
 ||kS)Nr)r�rJrrr�_ne_F 
 szDistribution._ne_cCs0y|jStk 
 r*|j��|_}|SXdS)N)�_keyr�rr@)r�r6rrrr6M 
 s 
 zDistribution.keycCst|d�st|j�|_|jS)N�_parsed_version)r�r!rr�)r�rrrr�U 
 s 
 zDistribution.parsed_versioncCsXtjj}t|j|�}|sdS|js&dSt�d����dd�}t	� 
 |jft|��t �dS)Na> 
             '{project_name} ({version})' is being parsed as a legacy, 
             non PEP 440, 
             version. You may find odd behavior and sort order. 
             In particular it will be sorted as less than 0.0. It 
             is recommended to migrate to PEP 440 compatible 
             versions. 
 r�r�)rrrr�r�rTrUr<r�rlrmr��varsr)r��LV�	is_legacyrZrrr�_warn_legacy_version\ 
 sz!Distribution._warn_legacy_versioncCsTy|jStk 
 rN|��}|dkrJ|�|j�}d�|j|�}t||��|SXdS)Nz4Missing 'Version:' header and/or {} file at path: {})r�r��_get_version�_get_metadata_path_for_display�PKG_INFOr�rI)r�rr�rprrrrv 
 s 
  
 zDistribution.versioncCs2y|jStk 
 r*|�|���|_YnX|jS)z~ 
         A map of extra to its list of (direct) requirements 
         for this distribution, including the null extra. 
 )�Distribution_dep_mapr��_filter_extras�_build_dep_map)r�rrr�_dep_map� 
 s 
 zDistribution._dep_mapcCsvxpttd|��D]^}|}|�|�}|�d�\}}}|oFt|�pFt|�}|rPg}t|�pZd}|�|g��|�qW|S)z� 
         Given a mapping of extras to dependencies, strip off 
         environment markers and filter out any dependencies 
         not matching the markers. 
 Nrz)	r rrr�rvrwrtr�r)�dmr3�	new_extrar�r�r4�fails_markerrrrr�� 
 s 
  
 zDistribution._filter_extrascCsHi}x>dD]6}x0t|�|��D]\}}|�|g��t|��qWq 
 W|S)N)zrequires.txtzdepends.txt)rs� _get_metadatar�rrm)r�r�r�r3r�rrrr�� 
 s 
  
 zDistribution._build_dep_maprc	Csj|j}g}|�|�dd��xH|D]@}y|�|t|��Wq"tk 
 r`td||f��Yq"Xq"W|S)z@List of Requirements needed for this distro if `extras` are usedNrz%s has no such extra feature %r)r�rr�rtr�rk)r�rr��depsrrrrr� 
 s 
 zDistribution.requirescCs*y|j�|�}Wntk 
 r$dSX|S)zK 
         Return the path to the given metadata file, if available. 
 z[could not detect])r�r�r^)r�r�r�rrrr�� 
 s 
 z+Distribution._get_metadata_path_for_displayccs(|�|�r$x|�|�D] 
 }|VqWdS)N)r�r�)r�r�r=rrrr�� 
 s 
 zDistribution._get_metadatacCs|�|j�}t|�}|S)N)r�r�r�)r�r�rrrrr�� 
 szDistribution._get_versionFcCsZ|dkrtj}|j||d�|tjkrVt|j�x$|�d�D]}|tjkr<t|�q<WdS)z>Ensure distribution is importable on `path` (default=sys.path)N)r�znamespace_packages.txt)rDr�rr�rr�r�r[)r�r�r��pkgrrr�activate� 
 s 
  
  
 zDistribution.activatecCs8dt|j�t|j�|jptf}|jr4|d|j7}|S)z@Return what this distribution's standard .egg filename should bez 
 %s-%s-py%sr{)rurrr<rOrE)r�rtrrrr�� 
 szDistribution.egg_namecCs |jrd||jfSt|�SdS)Nz%s (%s))rr�)r�rrrr�� 
 szDistribution._repr_cCs@yt|dd�}Wntk 
 r(d}YnX|p0d}d|j|fS)Nrz[unknown version]z%s %s)r�rIr)r�rrrrr�� 
 s 
 zDistribution._strcCs|�d�rt|��t|j|�S)zADelegate all unrecognized public attributes to .metadata providerr�)r�r�r�r�)r�r�rrr�getattr_� 
 s 
 zDistribution._getattrcs.tttt|����tdd�|j��D��B�S)Ncss|]}|�d�s|VqdS)r�N)r�)rr�rrrrsz'Distribution.dir.<locals>.<genexpr>)r r�superre�dirr�)r�)r�rrr�szDistribution.dir_r�cKs|jt|�tj�|�|f|�S)N)rr!r�r�r�)r�rtrr(rrrrszDistribution.from_filenamecCs<t|jtjj�r"d|j|jf}nd|j|jf}t�|�S)z?Return a ``Requirement`` that matches this distribution exactlyz%s==%sz%s===%s)r�r�rrrrrfr�)r��specrrrr#szDistribution.as_requirementcCs.|�||�}|dkr&td||ff��|��S)z=Return the `name` entry point of `group` or raise ImportErrorNzEntry point %r not found)rSr�r�)r�rHr�r�rrrrQszDistribution.load_entry_pointcCsPy 
 |j}Wn,tk 
 r6t�|�d�|�}|_YnX|dk	rL|�|i�S|S)z=Return the entry point map for `group`, or the full entry mapzentry_points.txtN)�_ep_mapr�rgr�r�r�)r�rH�ep_maprrrrR&s 
 zDistribution.get_entry_mapcCs|�|��|�S)z<Return the EntryPoint object for `group`+`name`, or ``None``)rRr�)r�rHr�rrrrS2szDistribution.get_entry_infoc 
 Cs0|p|j}|sdSt|�}tj�|�}dd�|D�}x�t|�D]t\}}||kr\|rVPq�dSq>||kr>|jtkr>|s�|||d�kr�dS|tjkr�|�	�|� 
 ||�|� 
 ||�Pq>W|tjkr�|�        �|r�|� 
 d|�n 
 |�|�dSxBy|�||d�}        Wnt k 
 �rPYq�X||	=||	=|	}q�WdS)a�Ensure self.location is on path 
  
         If replace=False (default): 
             - If location is already in path anywhere, do nothing. 
             - Else: 
               - If it's an egg and its parent directory is on path, 
                 insert just ahead of the parent. 
               - Else: add to the end of path. 
         If replace=True: 
             - If location is already on path anywhere (not eggs) 
               or higher priority than its parent (eggs) 
               do nothing. 
             - Else: 
               - If it's an egg and its parent directory is on path, 
                 insert just ahead of the parent, 
                 removing any lower-priority entries. 
               - Else: add it to the front of path. 
 NcSsg|]}|rt|�p|�qSr)r!)rrUrrrrPsz*Distribution.insert_on.<locals>.<listcomp>rr)rr!r�r�r��	enumerater:rzrD�check_version_conflictr	r�rWrI) 
 r�r��locr��nloc�bdir�npathrUr�nprrrr6sB 
  
  
  
 zDistribution.insert_oncCs�|jdkrdSt�|�d��}t|j�}x~|�d�D]p}|tjks4||ks4|tkrTq4|dkr^q4t	tj|dd�}|r�t|�� 
 |�s4|� 
 |j�r�q4td|||jf�q4WdS)N� 
 setuptoolsznamespace_packages.txtz top_level.txt)� pkg_resourcesr��siter�zIModule %s was already imported from %s, but %s is being added to sys.path)r6r%r&r�ryrrDr�rFr�r�� issue_warning)r��nspr��modname�fnrrrr�zs" 
  
 z#Distribution.check_version_conflictcCs4y 
 |jWn$tk 
 r.tdt|��dSXdS)NzUnbuilt egg for FT)rrIr�r�)r�rrrrE�s 
 zDistribution.has_versioncKsDd}x$|��D]}|�|t||d��qW|�d|j�|jf|�S)z@Copy this distribution, substituting in any changed keyword argsz<project_name version py_version platform location precedenceNr)rr�r�r�r�)r�r(rar�rrr�clone�s 
 zDistribution.clonecCsdd�|jD�S)NcSsg|]}|r|�qSrr)r�deprrrr�sz'Distribution.extras.<locals>.<listcomp>)r�)r�rrrr�szDistribution.extras)N)r)NF)N)N)NF)3rrrrr�rOrzr�r2rr�r�rCr�r�r�r�r�r�r�r6r�r�rr�rwr�r�rr�r�r�r�r�r�r�r�r�r��objectrr#rQrRrSrr�rEr�r� _classcell_rr)r�rre 
 s\ 
  
  
                  
  
 Dc@seZdZdd�ZdS)�EggInfoDistributioncCs|��}|r||_|S)a� 
         Packages installed by distutils (e.g. numpy or scipy), 
         which uses an old safe_version, and so 
         their version numbers can get mangled when 
         converted to filenames (e.g., 1.11.0.dev0+2329eae to 
         1.11.0.dev0_2329eae). These distributions will not be 
         parsed properly 
         downstream by Distribution and safe_version, so 
         take an extra step and try to get the version number from 
         the metadata file itself instead of the filename. 
         )r�r�)r�� 
 md_versionrrrr��sz#EggInfoDistribution._reload_versionN)rrrr�rrrrr��sr�c@s>eZdZdZdZe�d�Zedd��Z	edd��Z 
 dd        �Zd 
 S)�DistInfoDistributionzV 
     Wrap an actual or potential sys.path entry 
     w/metadata, .dist-info style. 
 �METADATAz([\(,])\s*(\d.?)\s([,\)])cCs@y|jStk 
 r:|�|j�}tj���|�|_|jSXdS)zParse and cache metadataN)�	_pkg_infor�r�r��email�parser�Parser�parsestr)r�rrrr�_parsed_pkg_info�sz%DistInfoDistribution._parsed_pkg_infocCs,y|jStk 
 r&|��||jSXdS)N)�_DistInfoDistribution_dep_mapr��_compute_dependencies)r�rrrr��s 
  
 zDistInfoDistribution._dep_mapcs�dgi}|_g�x&|j�d�p"gD]}��t|��q$W�fdd�}t|d��}|d�|�x<|j�d�ppgD](}t|���}tt||��|�||<qrW|S)z+Recompute this distribution's dependencies.Nz Requires-Distc3s.x(�D] }|jr |j�d|i�r|VqWdS)Nr3)r4r5)r3r�)r�rr�reqs_for_extra�s 
 zBDistInfoDistribution._compute_dependencies.<locals>.reqs_for_extrazProvides-Extra)	r�r��get_allrrm�	frozensetrtr<r )r�r�r�r��commonr3�s_extrar)r�rr��sz*DistInfoDistribution._compute_dependenciesN)rrrrr�r|r��EQEQr�r�r�r�rrrrr��s 
  
 r�)z.eggz        .egg-infoz 
 .dist-infocOs^d}t�}y"xt�|�j|kr(|d7}qWWntk 
 r@YnXtj|d|di|��dS)Nrr�)r"rDr�r�rIrlrm)r;r(r~r-rrrr��sr�c@seZdZdd�ZdS)�RequirementParseErrorcCsd�|j�S)Nr�)rFr;)r�rrrr��szRequirementParseError._str_N)rrrr�rrrrr��sr�c	cs�tt|��}xp|D]h}d|kr0|d|�d��}|�d�rp|dd���}y|t|�7}Wntk 
 rndSXt|�VqWdS)z�Yield ``Requirement`` objects for each specification in `strs` 
  
     `strs` must be a string, or a (possibly-nested) iterable thereof. 
 z #N�\�����)r.rrr�r r<r@� StopIterationrf)rsr�r=rrrrms 
  
 csPeZdZ�fdd�Zdd�Zdd�Zdd�Zd	d 
 �Zdd�Ze        d d��Z 
 �ZS)rfc 
 s�ytt|��|�Wn2tjjk 
 rF}ztt|���Wdd}~XYnX|j|_        t 
 |j�}||��|| dd�|jD�|ttt|j��||j |jt|j�|jr�t|j�ndf|t|j�|_dS)z>DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!NcSsg|]}|j|jf�qSr)rFr)rr�rrrr$sz(Requirement.init.<locals>.<listcomp>)r�rfr�rr�InvalidRequirementr�r�r��unsafe_namernr@rr6�	specifierr�rxrrtrr�r4�hashCmpr��_Requirement_hash)r��requirement_stringr�r)r�rrr�s 
 zRequirement._init_cCst|t�o|j|jkS)N)r�rfr�)r�rJrrrr�.s 
 zRequirement._eq_cCs 
 ||kS)Nr)r�rJrrrr�4szRequirement._ne_cCs0t|t�r |j|jkrdS|j}|jj|dd�S)NFT)�prereleases)r�rer6rr��contains)r�rrrrr�7s 
  
 zRequirement._containscCs|jS)N)r�)r�rrrr�CszRequirement.hashcCsdt|�S)NzRequirement.parse(%r))r�)r�rrrr�FszRequirement.repr_cCst|�\}|S)N)rm)rtr�rrrr�Is 
 zRequirement.parse)rrrr�r�r�r�r�r�rwr�r�rr)r�rrfscCst|kr|tfS|S)zJ 
     Ensure object appears in the mro even 
     for old-style classes. 
 )r�)�classesrrr�_always_objectOs 
 r�cCs<tt�t|dt|����}x|D]}||kr ||Sq WdS)z2Return an adapter factory for `ob` from `registry`r�N)r��inspect�getmror�r�)�registryr7rM�trrrr�Ys 
 r�cCstj�|�}tj|dd�dS)z1Ensure that the parent directory of `path` existsT)�exist_okN)r�r�r�r�makedirs)r�r�rrrrxascCsXtstd��t|�\}}|rT|rTt|�sTt|�yt|d�Wntk 
 rRYnXdS)z/Sandbox-bypassing version of ensure_directory()z*"os.mkdir" not supported on this platform.i�N)r�r�rr r]r	�FileExistsError)r�r�rtrrrr]gsr]ccszd}g}xbt|�D]V}|�d�r^|�d�rR|s2|r<||fV|dd���}g}qhtd|��q|�|�qW||fVdS)asSplit a string or iterable thereof into (section, content) pairs 
  
     Each ``section`` is a stripped version of the section header ("[section]") 
     and each ``content`` is a list of stripped lines excluding blank lines and 
     comment-only lines.  If there are any such lines before the first section 
     header, they're returned in a first ``section`` of ``None``. 
 N�[�]rr�zInvalid section heading)rrr�r r<rIr�)rt�section�contentr=rrrrsts 
  
  
 cOs&tj}ztt_tj||
